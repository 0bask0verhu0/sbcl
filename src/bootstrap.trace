
;;;; component: "top level form"


IR1 block 0 start c1
start stack:
  1>     bind SB!C::CLAMBDA (SB!C::TOP-LEVEL-FORM NIL) :KIND :TOPLEVEL
  2>  3: FIND-UNDELETED-PACKAGE-OR-LOSE {GLOBAL-FUNCTION}
  4>  5: '"SB!KERNEL"
  6>  7: known combination v3 v5
  8>     set *PACKAGE* {SPECIAL} v7
  9> 10: 'NIL
 11>     return v10 SB!C::CLAMBDA (SB!C::TOP-LEVEL-FORM NIL)
end stack:
successors c12


;;;; IR2 component: "top level form"

entries:
    L1: (SB!C::TOP-LEVEL-FORM NIL)


TNs: 17 local, 12 temps, 4 constant, 2 env, 0 comp, 2 global.
Wired: 21, Unused: 0. 1 block, 4 global conflicts.

IR1 block 3 start c12

    IR2 block NIL start c12

IR1 block 0 start c1

    IR2 block 0 start c1
    0: XEP-ALLOCATE-FRAME {#<SB!ASSEM:LABEL 1>}
    1: XEP-SETUP-SP
    2: MOVE t1[CS0]>t2[NL0] => t3[CS0]<t4[NL0]
    3: MOVE t5[CS1]>t6[R0] => t7[CS1]<t8[R0]
    4: NOTE-ENVIRONMENT-START {#<SB!ASSEM:LABEL 2>}
    5: ALLOCATE-FULL-CALL-FRAME {1} => t9[OCFP]
    6: MOVE-ARG '"SB!KERNEL"!10[Const4]>t11[R0] t9[OCFP] => t12[R0]
    7: CALL-NAMED t9[OCFP] t13[Const5] t12[R0] {# 1 1 NIL} => t14[R0]
    8: MOVE t14[R0] => t15[R0]
    9: SET '*PACKAGE*!16[Const6]>t17[R1] t15[R0]
    10: MOVE 'NIL!18 => t19[R0]
    11: RETURN-SINGLE t3[CS0]>t20[NL0] t7[CS1]>t21[R1] t19[R0]

IR1 block 1 start c12

    IR2 block NIL start c12



assembly code for #<SB!C:COMPONENT :NAME "top level form" {1014292303}>

in the ELSEWHERE segment:
L3:
in the REGULAR segment:
L4:
in the ELSEWHERE segment:
L5:
in the REGULAR segment:

VOP XEP-ALLOCATE-FRAME {#<SB!ASSEM:LABEL 1>} 
        .align  4
L1:
        SIMPLE-FUN-HEADER-WORD
        DWORD   0
        DWORD   0
        DWORD   0
        DWORD   0
        DWORD   0
        DWORD   0
        COMPUTE-CODE    #<TN t22[CODE]>, #<TN t23[LR]>, L1, #<TN t24[NL0]>

VOP XEP-SETUP-SP 
        ADD     #<TN t25[CSP]>, #<TN t26[CFP]>, 24

VOP NOTE-ENVIRONMENT-START {#<SB!ASSEM:LABEL 2>} 
L2:

VOP ALLOCATE-FULL-CALL-FRAME {1} => t9[OCFP] 
        ORR     #<TN t9[OCFP]>, #<TN t27[ZR]>, #<TN t25[CSP]>
        ADD     #<TN t25[CSP]>, #<TN t25[CSP]>, 16
        STR     #<TN t26[CFP]>, #S(SB!VM::MEMORY-OPERAND
                                   :BASE #<TN t9[OCFP]>
                                   :OFFSET 0
                                   :MODE OFFSET)

VOP MOVE-ARG '"SB!KERNEL"!10[Const4]>t11[R0] t9[OCFP] => t12[R0] 
        LDR     #<TN t11[R0]>, #S(SB!VM::MEMORY-OPERAND
                                  :BASE #<TN t22[CODE]>
                                  :OFFSET 17
                                  :MODE OFFSET)

VOP CALL-NAMED t9[OCFP] t13[Const5] t12[R0] {# 1 1 NIL} => t14[R0] 
        LDR     #<TN t28[LEXENV]>, #S(SB!VM::MEMORY-OPERAND
                                      :BASE #<TN t22[CODE]>
                                      :OFFSET 25
                                      :MODE OFFSET)
        MOVZ    #<TN t29[NARGS]>, 2
        LDR     #<TN t30[R1]>, #S(SB!VM::MEMORY-OPERAND
                                  :BASE #<TN t28[LEXENV]>
                                  :OFFSET 9
                                  :MODE OFFSET)
        COMPUTE-LRA     #<TN t31[LR]>, #<TN t31[LR]>, L6
        STR     #<TN t31[LR]>, #S(SB!VM::MEMORY-OPERAND
                                  :BASE #<TN t9[OCFP]>
                                  :OFFSET 8
                                  :MODE OFFSET)
        ORR     #<TN t26[CFP]>, #<TN t27[ZR]>, #<TN t9[OCFP]>
L7:
        ADD     #<TN t32[TMP]>, #<TN t30[R1]>, 45
        BR      #<TN t32[TMP]>
        .align  4
L6:
        LRA-HEADER-WORD
L8:
        COMPUTE-CODE    #<TN t22[CODE]>, #<TN t31[LR]>, L6, #<TN t33[NL0]>
        CSEL    #<TN t25[CSP]>, #<TN t34[OCFP]>, #<TN t25[CSP]>, EQ

VOP SET '*PACKAGE*!16[Const6]>t17[R1] t15[R0] 
        LDR     #<TN t17[R1]>, #S(SB!VM::MEMORY-OPERAND
                                  :BASE #<TN t22[CODE]>
                                  :OFFSET 33
                                  :MODE OFFSET)
        STR     #<TN t15[R0]>, #S(SB!VM::MEMORY-OPERAND
                                  :BASE #<TN t17[R1]>
                                  :OFFSET -7
                                  :MODE OFFSET)

VOP MOVE 'NIL!18 => t19[R0] 
        ORR     #<TN t19[R0]>, #<TN t27[ZR]>, #<TN t35[NULL]>

VOP RETURN-SINGLE t3[CS0]>t20[NL0] t7[CS1]>t21[R1] t19[R0] 
        LDR     #<TN t20[NL0]>, #S(SB!VM::MEMORY-OPERAND
                                   :BASE #<TN t26[CFP]>
                                   :OFFSET 0
                                   :MODE OFFSET)
        LDR     #<TN t21[R1]>, #S(SB!VM::MEMORY-OPERAND
                                  :BASE #<TN t26[CFP]>
                                  :OFFSET 8
                                  :MODE OFFSET)
        ORR     #<TN t25[CSP]>, #<TN t27[ZR]>, #<TN t26[CFP]>
        ORR     #<TN t26[CFP]>, #<TN t27[ZR]>, #<TN t20[NL0]>
        MSR     NZCV, #<TN t27[ZR]>
        SUB     #<TN t32[TMP]>, #<TN t21[R1]>, 7
        BR      #<TN t32[TMP]>

        .align  4

;;;; component: BAR


IR1 block 0 start c13
start stack:
 13>     bind SB!C::CLAMBDA (SB!C::TL-XEP BAR) :KIND :EXTERNAL
 14> 15: SB!C::CLAMBDA BAR
 16> 17: #:G0
 18>     tail local combination v15 v17
end stack:
successors c19

IR1 block 1 start c19
start stack:
 19>     bind SB!C::CLAMBDA BAR
end stack:
successors c20

IR1 block 2 start c20
start stack:
 20>     entry NIL
 21> 22: VALUES {GLOBAL-FUNCTION}
 23> 24: X
 25> 26: '"Hello World"
 27> 28: known combination v22 v24 v26
end stack:
successors c29

IR1 block 3 start c29
start stack:
 29>     return v28 SB!C::CLAMBDA BAR
end stack:
successors c12


;;;; IR2 component: BAR

entries:
    L9: BAR


TNs: 12 local, 10 temps, 1 constant, 6 env, 0 comp, 5 global.
Wired: 23, Unused: 0. 4 blocks, 20 global conflicts.

IR1 block 6 start c12

    IR2 block NIL start c12

IR1 block 0 start c13

    IR2 block 3 start c13
    0: XEP-ALLOCATE-FRAME {#<SB!ASSEM:LABEL 9>}
    1: VERIFY-ARG-COUNT t36[NARGS] {NIL 1}
    2: XEP-SETUP-SP
    3: MOVE t37[R0] => #:G0!38[R0]
    4: MOVE t39[CS0]>t40[NL0] => t41[CS0]<t42[NL0]
    5: MOVE t43[CS1]>t44[R1] => t45[CS1]<t46[R1]
    6: NOTE-ENVIRONMENT-START {#<SB!ASSEM:LABEL 10>}
    7: MOVE #:G0!38[R0] => X!47[R0]
    8: MOVE t41[CS0]>t48[NL0] => t49[CS0]<t50[NL0]
    9: MOVE t45[CS1]>t51[R1] => t52[CS1]<t53[R1]

IR1 block 1 start c19

    IR2 block 2 start c19
    0: MOVE t52[CS1]>t54[R1] => t55[CS1]<t56[R1]
    1: NOTE-ENVIRONMENT-START {#<SB!ASSEM:LABEL 11>}

IR1 block 2 start c20

    IR2 block 1 start c20

IR1 block 3 start c29

    IR2 block 0 start c29
    0: MOVE X!47[R0] => t57[R0]
    1: MOVE '"Hello World"!58[Const4]>t59[R1] => t60[R1]
    2: RETURN t49[CS0]>t61[NL0] t55[CS1]>t62[LEXENV] t57[R0] t60[R1] {2}

IR1 block 1 start c12

    IR2 block NIL start c12



assembly code for #<SB!C:COMPONENT :NAME BAR {10142DF753}>

in the ELSEWHERE segment:
L12:
in the REGULAR segment:
L13:
in the ELSEWHERE segment:
L14:
in the REGULAR segment:

VOP XEP-ALLOCATE-FRAME {#<SB!ASSEM:LABEL 9>} 
        .align  4
L9:
        SIMPLE-FUN-HEADER-WORD
        DWORD   0
        DWORD   0
        DWORD   0
        DWORD   0
        DWORD   0
        DWORD   0
        COMPUTE-CODE    #<TN t22[CODE]>, #<TN t63[LR]>, L9, #<TN t64[NL2]>
in the ELSEWHERE segment:

VOP VERIFY-ARG-COUNT t36[NARGS] {NIL 1} 
L15:
L16:
        DEBUG-TRAP
        BYTE    10
        BYTE    4
        BYTE    25
        BYTE    254
        BYTE    132
        BYTE    5
        .align  3
in the REGULAR segment:
        SUBS    #<TN t27[ZR]>, #<TN t36[NARGS]>, 2
        B       NE, L15

VOP XEP-SETUP-SP 
        ADD     #<TN t25[CSP]>, #<TN t26[CFP]>, 16

VOP NOTE-ENVIRONMENT-START {#<SB!ASSEM:LABEL 10>} 
L10:

L17:
in the ELSEWHERE segment:
L18:
in the REGULAR segment:

VOP NOTE-ENVIRONMENT-START {#<SB!ASSEM:LABEL 11>} 
L11:

L19:
L20:

VOP MOVE '"Hello World"!58[Const4]>t59[R1] => t60[R1] 
        LDR     #<TN t59[R1]>, #S(SB!VM::MEMORY-OPERAND
                                  :BASE #<TN t22[CODE]>
                                  :OFFSET 17
                                  :MODE OFFSET)

VOP RETURN t49[CS0]>t61[NL0] t55[CS1]>t62[LEXENV] t57[R0] t60[R1] {2} 
        LDR     #<TN t61[NL0]>, #S(SB!VM::MEMORY-OPERAND
                                   :BASE #<TN t26[CFP]>
                                   :OFFSET 0
                                   :MODE OFFSET)
        LDR     #<TN t62[LEXENV]>, #S(SB!VM::MEMORY-OPERAND
                                      :BASE #<TN t26[CFP]>
                                      :OFFSET 8
                                      :MODE OFFSET)
        ORR     #<TN t65[OCFP]>, #<TN t27[ZR]>, #<TN t26[CFP]>
        ORR     #<TN t26[CFP]>, #<TN t27[ZR]>, #<TN t61[NL0]>
        ADD     #<TN t66[NARGS]>, #<TN t65[OCFP]>, 16
        ORR     #<TN t25[CSP]>, #<TN t27[ZR]>, #<TN t66[NARGS]>
        MOVZ    #<TN t66[NARGS]>, 4
        ORR     #<TN t67[R2]>, #<TN t27[ZR]>, #<TN t35[NULL]>
        ORR     #<TN t32[TMP]>, #<TN t27[ZR]>, 4026531840
        MSR     NZCV, #<TN t32[TMP]>
        SUB     #<TN t32[TMP]>, #<TN t68[LEXENV]>, 7
        BR      #<TN t32[TMP]>

        .align  4

;;;; component: !COLD-INIT


IR1 block 0 start c30
start stack:
 30>     bind SB!C::CLAMBDA (SB!C::TL-XEP !COLD-INIT) :KIND :EXTERNAL
 31> 32: SB!C::CLAMBDA !COLD-INIT
 33>     tail local combination v32
end stack:
successors c34

IR1 block 1 start c34
start stack:
 34>     bind SB!C::CLAMBDA !COLD-INIT
end stack:
successors c35

IR1 block 2 start c35
start stack:
 35>     entry NIL
 36> 37: CONS {GLOBAL-FUNCTION}
 38> 39: '20
 40> 41: '30
 42> 43: known combination v37 v39 v41
end stack:
successors c44

IR1 block 3 start c44
start stack:
 44>     return v43 SB!C::CLAMBDA !COLD-INIT
end stack:
successors c12


;;;; IR2 component: !COLD-INIT

entries:
    L21: !COLD-INIT


TNs: 6 local, 5 temps, 2 constant, 4 env, 0 comp, 5 global.
Wired: 15, Unused: 0. 4 blocks, 16 global conflicts.

IR1 block 6 start c12

    IR2 block NIL start c12

IR1 block 0 start c30

    IR2 block 3 start c30
    0: XEP-ALLOCATE-FRAME {#<SB!ASSEM:LABEL 21>}
    1: VERIFY-ARG-COUNT t69[NARGS] {NIL 0}
    2: XEP-SETUP-SP
    3: MOVE t70[CS0]>t71[NL0] => t72[CS0]<t73[NL0]
    4: MOVE t74[CS1]>t75[R0] => t76[CS1]<t77[R0]
    5: NOTE-ENVIRONMENT-START {#<SB!ASSEM:LABEL 22>}
    6: MOVE t72[CS0]>t78[NL0] => t79[CS0]<t80[NL0]
    7: MOVE t76[CS1]>t81[R0] => t82[CS1]<t83[R0]

IR1 block 1 start c34

    IR2 block 2 start c34
    0: MOVE t82[CS1]>t84[R0] => t85[CS1]<t86[R0]
    1: NOTE-ENVIRONMENT-START {#<SB!ASSEM:LABEL 23>}

IR1 block 2 start c35

    IR2 block 1 start c35
    0: FIXED-ALLOC {CONS 2 NIL 7 NIL} => t87[R0]
    1: INIT-SLOT t87[R0] '20!88>t89[NL0] {CONS 0 7}
    2: INIT-SLOT t87[R0] '30!90>t91[NL0] {CONS 1 7}

IR1 block 3 start c44

    IR2 block 0 start c44
    0: MOVE t87[R0] => t92[R0]
    1: RETURN-SINGLE t79[CS0]>t93[NL0] t85[CS1]>t94[R1] t92[R0]

IR1 block 1 start c12

    IR2 block NIL start c12



assembly code for #<SB!C:COMPONENT :NAME !COLD-INIT {1014327383}>

in the ELSEWHERE segment:
L24:
in the REGULAR segment:
L25:
in the ELSEWHERE segment:
L26:
in the REGULAR segment:

VOP XEP-ALLOCATE-FRAME {#<SB!ASSEM:LABEL 21>} 
        .align  4
L21:
        SIMPLE-FUN-HEADER-WORD
        DWORD   0
        DWORD   0
        DWORD   0
        DWORD   0
        DWORD   0
        DWORD   0
        COMPUTE-CODE    #<TN t22[CODE]>, #<TN t95[LR]>, L21, #<TN t96[NL2]>
in the ELSEWHERE segment:

VOP VERIFY-ARG-COUNT t69[NARGS] {NIL 0} 
L27:
L28:
        DEBUG-TRAP
        BYTE    10
        BYTE    4
        BYTE    25
        BYTE    254
        BYTE    132
        BYTE    5
        .align  3
in the REGULAR segment:
        SUBS    #<TN t27[ZR]>, #<TN t69[NARGS]>, 0
        B       NE, L27

VOP XEP-SETUP-SP 
        ADD     #<TN t25[CSP]>, #<TN t26[CFP]>, 16

VOP NOTE-ENVIRONMENT-START {#<SB!ASSEM:LABEL 22>} 
L22:

L29:
in the ELSEWHERE segment:
L30:
in the REGULAR segment:

VOP NOTE-ENVIRONMENT-START {#<SB!ASSEM:LABEL 23>} 
L23:

L31:

VOP FIXED-ALLOC {CONS 2 NIL 7 NIL} => t87[R0] 
        MOVZ    #<TN t32[TMP]>, 2209
        STR     #<TN t25[CSP]>, #S(SB!VM::MEMORY-OPERAND
                                   :BASE #<TN t35[NULL]>
                                   :OFFSET #<TN t32[TMP]>
                                   :MODE OFFSET)
        LOAD-FROM-LABEL #<TN t97[OCFP]>, L32
        LDR     #<TN t87[R0]>, #S(SB!VM::MEMORY-OPERAND
                                  :BASE #<TN t97[OCFP]>
                                  :OFFSET 0
                                  :MODE OFFSET)
        LDR     #<TN t97[OCFP]>, #S(SB!VM::MEMORY-OPERAND
                                    :BASE #<TN t97[OCFP]>
                                    :OFFSET 8
                                    :MODE OFFSET)
        ADD     #<TN t87[R0]>, #<TN t87[R0]>, 16
        SUBS    #<TN t27[ZR]>, #<TN t87[R0]>, #<TN t97[OCFP]>
        B       HI, L33
        LOAD-FROM-LABEL #<TN t97[OCFP]>, L32
        STR     #<TN t87[R0]>, #S(SB!VM::MEMORY-OPERAND
                                  :BASE #<TN t97[OCFP]>
                                  :OFFSET 0
                                  :MODE OFFSET)
        SUB     #<TN t87[R0]>, #<TN t87[R0]>, 16
L34:
        ADD     #<TN t87[R0]>, #<TN t87[R0]>, 7
in the ELSEWHERE segment:
L33:
        MOVZ    #<TN t87[R0]>, 16
        STP     #<TN t87[R0]>, #<TN t98[LR]>, #S(SB!VM::MEMORY-OPERAND
                                                 :BASE #<TN t99[ZR]>
                                                 :OFFSET -16
                                                 :MODE PRE-INDEX)
        LOAD-FROM-LABEL #<TN t87[R0]>, L35
        BLR     #<TN t87[R0]>
        LDP     #<TN t87[R0]>, #<TN t98[LR]>, #S(SB!VM::MEMORY-OPERAND
                                                 :BASE #<TN t99[ZR]>
                                                 :OFFSET 16
                                                 :MODE POST-INDEX)
        B       L34
L35:
        DWORD   #S(SB!C:FIXUP :NAME alloc_tramp :FLAVOR FOREIGN :OFFSET NIL)
L32:
        DWORD   #S(SB!C:FIXUP :NAME boxed_region :FLAVOR FOREIGN :OFFSET NIL)
in the REGULAR segment:
        MOVZ    #<TN t32[TMP]>, 2209
        STR     #<TN t35[NULL]>, #S(SB!VM::MEMORY-OPERAND
                                    :BASE #<TN t35[NULL]>
                                    :OFFSET #<TN t32[TMP]>
                                    :MODE OFFSET)
        MOVZ    #<TN t32[TMP]>, 2257
        LDR     #<TN t97[OCFP]>, #S(SB!VM::MEMORY-OPERAND
                                    :BASE #<TN t35[NULL]>
                                    :OFFSET #<TN t32[TMP]>
                                    :MODE OFFSET)
        CBZ     #<TN t97[OCFP]>, L36
        BLR     #<TN t97[OCFP]>
L36:

VOP INIT-SLOT t87[R0] '20!88>t89[NL0] {CONS 0 7} 
        MOVZ    #<TN t89[NL0]>, 40
        STR     #<TN t89[NL0]>, #S(SB!VM::MEMORY-OPERAND
                                   :BASE #<TN t87[R0]>
                                   :OFFSET -7
                                   :MODE OFFSET)

VOP INIT-SLOT t87[R0] '30!90>t91[NL0] {CONS 1 7} 
        MOVZ    #<TN t91[NL0]>, 60
        STR     #<TN t91[NL0]>, #S(SB!VM::MEMORY-OPERAND
                                   :BASE #<TN t87[R0]>
                                   :OFFSET 1
                                   :MODE OFFSET)

L37:

VOP RETURN-SINGLE t79[CS0]>t93[NL0] t85[CS1]>t94[R1] t92[R0] 
        LDR     #<TN t93[NL0]>, #S(SB!VM::MEMORY-OPERAND
                                   :BASE #<TN t26[CFP]>
                                   :OFFSET 0
                                   :MODE OFFSET)
        LDR     #<TN t94[R1]>, #S(SB!VM::MEMORY-OPERAND
                                  :BASE #<TN t26[CFP]>
                                  :OFFSET 8
                                  :MODE OFFSET)
        ORR     #<TN t25[CSP]>, #<TN t27[ZR]>, #<TN t26[CFP]>
        ORR     #<TN t26[CFP]>, #<TN t27[ZR]>, #<TN t93[NL0]>
        MSR     NZCV, #<TN t27[ZR]>
        SUB     #<TN t32[TMP]>, #<TN t94[R1]>, 7
        BR      #<TN t32[TMP]>

        .align  4
