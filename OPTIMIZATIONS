(defun mysl (s)
    (declare (simple-string s))
    (declare (optimize (speed 3) (safety 0) (debug 0)))
    (let ((c 0))
      (declare (fixnum c))
      (dotimes (i (length s))
        (when (eql (aref s i) #\1)
          (incf c)))
      c))

* On X86 I is represented as a tagged integer.

* EQL uses "CMP reg,reg" instead of "CMP reg,im". This causes
  allocation of an extra register and an extra move.

* Unnecessary move:
  3: SLOT S!11[EDX] {SB-C::VECTOR-LENGTH 1 7} => t23[EAX]
  4: MOVE t23[EAX] => t24[EBX]

--------------------------------------------------------------------------------
(defun quux (v)
  (declare (optimize (speed 3) (safety 0) (space 2) (debug 0)))
  (declare (type (simple-array double-float 1) v))
  (let ((s 0d0))
    (declare (type double-float s))
    (dotimes (i (length v))
      (setq s (+ s (aref v i))))
    s))

* Python does not combine + with AREF, so generates extra move and
  allocates a register.

* On X86 Python thinks that all FP registers are directly accessible
  and emits costy MOVE ... => FR1.

--------------------------------------------------------------------------------
(defun bar (n)
  (declare (optimize (speed 3) (safety 0) (space 2))
           (type fixnum n))
  (let ((v (make-list n)))
    (setq v (make-array n))
    (length v)))

* IR1 does not optimize away (MAKE-LIST N).

* IR1 thinks that the type of V in (LENGTH V) is (OR LIST SIMPLE-VECTOR), not
  SIMPLE-VECTOR.
--------------------------------------------------------------------------------
(defun bar (v1 v2)
  (declare (optimize (speed 3) (safety 0) (space 2))
           (type (simple-array base-char 1) v1 v2))
  (dotimes (i (length v1))
    (setf (aref v2 i) (aref v1 i))))

VOP DATA-VECTOR-SET/SIMPLE-STRING V2!14[EDI] t32[EAX] t30[S2]>t33[CL]
                                  => t34[S2]<t35[AL] 
        MOV     #<TN t33[CL]>, #<TN t30[S2]>
        MOV     BYTE PTR [EDI+EAX+1], #<TN t33[CL]>
        MOV     #<TN t35[AL]>, #<TN t33[CL]>
        MOV     #<TN t34[S2]>, #<TN t35[AL]>

* The value of DATA-VECTOR-SET is not used, so there is no need in the
  last two moves.

* And why two moves?
--------------------------------------------------------------------------------
(loop repeat 1.5)

uses generic arithmetic
--------------------------------------------------------------------------------
09:49:05 <jtra> I have found a case in those where suboptimal code is
  generate with nested loops, it might be moderately easy to fix that
09:49:28 <jtra> see
  http://www.bagley.org/~doug/shootout/bench/nestedloop/nestedloop.cmucl
09:50:30 <jtra> if you add declarations to dotimes, generated code is
  almost optimal, but most inner loops run out of registers and use
  memory location for iteration variable

;;; -*- mode: lisp -*-
;;; $Id$
;;; http://www.bagley.org/~doug/shootout/
;;; from Friedrich Dominicus

(defun main ()
  (let ((n (parse-integer (or (car (last extensions:*command-line-strings*)) "1")))
        (x 0))
    (declare (fixnum n)
             (fixnum x)
             (optimize (speed 3) (debug 0) (safety 0)))
    (dotimes (a n)
      (dotimes (b n)
        (dotimes (c n)
          (dotimes (d n)
            (dotimes (e n)
              (dotimes (f n)
                (incf x)))))))
   (format t "~A~%" x)))
--------------------------------------------------------------------------------
